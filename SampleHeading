
/**
 * Simple Simulation of headings bouncing back and forth over True North
 * Includes noise on simulted gyro return
 * 
 * @author Howard Bishop 
 * @version 20161228.b
 *  a.  basic simulation with wrap around the 0/360 barrier  20161228.a   HCB
 *  b.  (development) Some debug, simplification.  Broke "getNewHeading" into 
 *      a separate method for maintainability and portability. 20161229.b HCB
*/
import java.util.concurrent.ThreadLocalRandom;
public class Headings
{
    private static int leg; // loop control variable.  
    /*
    *   adding new legs is a matter of adding a new heading and a 
    *   rotation direction to these arrays ... and finding 
    *   a way to make sure we loop to the correct number of legs
    *   Long term implication means we should be able to make a navigation
    *   "plan" and changes to it just by changing these vectors.
    *   Adding steps to do logic in "straight line" mode should be just some
    *   more array elements with "0" for the turn, and logic added for color detection
    *  and other servo/motor actions.  A switch could work nicely for this inside of the for loop
    */
    public static int[] Headings = {
        182, 178, 2, 357, 12
    };
    public static int[] rotationDir = {
        1,  -1,   1,  -1, -1
    };
    public static int[] numberSteps = {
           0,    0,   0,   0,  0
    };
    public static int[] Arrival = {
           0,    0,   0,   0,  0
    };
    public static int prevHeading = 178;
    public static int newHeading = 178;
    private static int deltaHeading = 0;
    /**
     * Constructor for objects of class Headings
     */
    public static void Headings()
    {
		int accumTurn = 0;
        System.out.printf ("VVVVVVVVVVVVVVVVVVVVVVVV\n");       
        //int deltaHeading;
        for (leg = 0; leg < 5; leg++) {
		    int currHeading = getHeading();
		    int desiredRotation = getNewHeading(currHeading);
            prevHeading = currHeading;
            accumTurn = 0;
            while(accumTurn < desiredRotation){
               // motor command goes here
               numberSteps[leg]++;
                currHeading = getHeading();
                if (Math.abs(prevHeading - currHeading) > 350) {
                    if (prevHeading < currHeading) {
                        accumTurn += prevHeading + 360 - currHeading;
                    }
                    else {
                        accumTurn += currHeading + 360 - prevHeading;
                    }
                }
                else {
                    accumTurn += Math.abs(prevHeading - currHeading);
                }             
                prevHeading = currHeading; 
               // System.out.printf("%d %d ",Headings[leg], rotationDir[leg]);
               // System.out.printf("%d %d %d\n", accumTurn,currHeading,numberSteps[leg]);              
            }  
            Arrival[leg] = currHeading;        
        }
        System.out.printf("\nleg\t steps\t Heading\t Arrived\n");
        for (int j = 0; j < 5; j++) {  
            int x = j+1;
            System.out.printf("%d\t %d\t %d\t\t %d\n",x,  numberSteps[j], Headings[j], Arrival[j]);
        }
        System.out.printf("----------end---------\n\n");
    }
    /***********************************************/
    /**          calculate necessary turn amount  **/  
    /***********************************************/
    public static int getNewHeading(int instHeading) {
        int neededTurn = 0;
	    if (rotationDir[leg] > 0) {
            // rotationDir[i] > 0 means clockwise turn
            if (Headings[leg] > instHeading) {
				neededTurn = Headings[leg] - instHeading;
			}
			else {
                neededTurn = Headings[leg] + 360 - instHeading;
            }
        }
        else if (rotationDir[leg] < 0) {
            // rotationDir[i] < 0 means anti clockwise
            if (Headings[leg] > instHeading) {
                neededTurn = 360 - Headings[leg] + instHeading;
			}
			else {
				neededTurn = instHeading - Headings[leg];
            }           
        }
        else {
            // rotationDir[i] == 0 ... means no turn commnded.
            neededTurn = 0; // redundant but cheap insurance.
        }
        
        System.out.printf("neededTurn[%d] = %d\n",leg, neededTurn);
        return (neededTurn);
	}

    /***********************************************/
    public static int headingCheck(int headingvalue)
    {
        if (headingvalue >= 360) {
           headingvalue = headingvalue - 360;
        }
        else if (headingvalue < 0) {
            headingvalue = headingvalue + 360;
        }
        return (headingvalue);
    }

    /***********************************************/
    public static int getHeading()
    {
        // bogus getHeading.  Has noise for sim.  otherwise
        // increments or decrements depending on chosen leg's 
        // rotation direction.
        int direction = rotationDir[leg];
        int headingNoise =ThreadLocalRandom.current().nextInt(0, 2) - 1;
        //headingNoise = 0;
        if (direction == 0) { 
           //newHeading = newHeading;
        }
        else if (direction == -1) {
            //newHeading--;
            newHeading = newHeading - 2;
        }
        else if (direction == 1) {
            //newHeading++;
            newHeading = newHeading + 2;
        }
        newHeading += headingNoise;
        newHeading = headingCheck(newHeading); 

        return (newHeading);
    }
    /***********************************************/
    public static void main (String args[]) {
		Headings();
	}   
}
